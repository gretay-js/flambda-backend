(rule
 (alias   runtest)
 (enabled_if (= %{context_name} "main"))
 (deps s.ml t.ml)
 (action (run %{bin:ocamlopt.opt} %{deps} -c -alloc-check -O3)))

(rule
 (alias   runtest)
 (enabled_if (= %{context_name} "main"))
 (deps test_assume.ml)
 (action (run %{bin:ocamlopt.opt} %{deps} -c -alloc-check -O3)))

(rule
 (alias   runtest)
 (enabled_if (and (= %{context_name} "main")
                   %{ocaml-config:flambda}
                  ;; what we really want to say but dune doesn't know about flambda2:
                  ;; (or %{ocaml-config:flambda} %{ocaml-config:flambda2})
                  ))
 (deps test_flambda.ml)
 (action (run %{bin:ocamlopt.opt} %{deps} -c -alloc-check -O3)))

(rule
 (enabled_if (= %{context_name} "main"))
 (targets fail1.output.corrected)
 (deps fail1.ml)
 (action
   (with-outputs-to fail1.output.corrected
    (pipe-outputs
    (with-accepted-exit-codes 2
     (run %{bin:ocamlopt.opt} %{deps} -color never -error-style short -c -alloc-check -O3))
    (bash "sed 's/Error: Annotation check for noalloc failed on function .*$/Error: Annotation check for noalloc failed on function HIDE_NAME/'")
   ))))

(rule
 (alias   runtest)
 (enabled_if (= %{context_name} "main"))
 (deps fail1.output fail1.output.corrected)
 (action (diff fail1.output fail1.output.corrected)))

(rule
 (enabled_if (= %{context_name} "main"))
 (targets fail2.output.corrected)
 (deps fail2.ml)
 (action
   (with-outputs-to fail2.output.corrected
    (pipe-outputs
    (with-accepted-exit-codes 2
     (run %{bin:ocamlopt.opt} %{deps} -color never -error-style short -c -alloc-check -O3))
    (bash "sed 's/Error: Annotation check for noalloc failed on function .*$/Error: Annotation check for noalloc failed on function HIDE_NAME/'")
   ))))

(rule
 (alias   runtest)
 (enabled_if (= %{context_name} "main"))
 (deps fail2.output fail2.output.corrected)
 (action (diff fail2.output fail2.output.corrected)))

(rule
 (enabled_if (= %{context_name} "main"))
 (targets fail3.output.corrected)
 (deps t3.ml fail3.ml)
  (action
   (with-outputs-to fail3.output.corrected
    (pipe-outputs
    (with-accepted-exit-codes 2
     (run %{bin:ocamlopt.opt} %{deps} -color never -error-style short -c -alloc-check -O3))
    (bash "sed 's/Error: Annotation check for noalloc failed on function .*$/Error: Annotation check for noalloc failed on function HIDE_NAME/'")
   ))))

(rule
 (alias   runtest)
 (enabled_if (= %{context_name} "main"))
 (deps fail3.output fail3.output.corrected)
 (action (diff fail3.output fail3.output.corrected)))


(rule
 (enabled_if (= %{context_name} "main"))
 (targets fail4.output.corrected)
 (deps t4.ml fail4.ml)
  (action
   (with-outputs-to fail4.output.corrected
    (pipe-outputs
    (with-accepted-exit-codes 2
     (run %{bin:ocamlopt.opt} %{deps} -color never -error-style short -c -alloc-check -O3))
    (bash "sed 's/Error: Annotation check for noalloc failed on function .*$/Error: Annotation check for noalloc failed on function HIDE_NAME/'")
   ))))

(rule
 (alias   runtest)
 (enabled_if (= %{context_name} "main"))
 (deps fail4.output fail4.output.corrected)
 (action (diff fail4.output fail4.output.corrected)))
